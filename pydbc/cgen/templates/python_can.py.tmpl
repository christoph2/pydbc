## -*- coding: utf-8 -*-
## Mako template: python-can app generated by pydbc
<%
# messages: List[CGMessage]
# app_name: str
%>
"""
Auto-generated python-can application: ${app_name}

Generated by pydbc using Mako templates. This code is standalone and embeds
all message/signal metadata (no runtime database needed).

Limitations:
- Only little-endian signals are handled in the helpers below.
- Multiplexing not implemented in this minimal generator.
"""
from __future__ import annotations

from typing import Dict, Any, Optional

try:
    import can  # type: ignore
except Exception as exc:  # pragma: no cover
    raise RuntimeError(
        "python-can is required for this generated app. Install with 'pip install python-can'."
    ) from exc


# --- Bit helpers (little-endian/Intel) ---
def _ins_bits_le(buf, start_bit, size, value):
    if size <= 0:
        return
    mask = (1 << size) - 1
    value &= mask
    bit_pos = start_bit
    remaining = size
    while remaining > 0:
        byte_index = bit_pos // 8
        bit_index = bit_pos % 8
        bits_here = min(remaining, 8 - bit_index)
        chunk_mask = (1 << bits_here) - 1
        chunk = value & chunk_mask
        buf[byte_index] &= ~(chunk_mask << bit_index)
        buf[byte_index] |= (chunk << bit_index)
        value >>= bits_here
        remaining -= bits_here
        bit_pos += bits_here


def _ext_bits_le(buf, start_bit, size, signed):
    if size <= 0:
        return 0
    bit_pos = start_bit
    remaining = size
    out = 0
    shift = 0
    while remaining > 0:
        byte_index = bit_pos // 8
        bit_index = bit_pos % 8
        bits_here = min(remaining, 8 - bit_index)
        chunk_mask = (1 << bits_here) - 1
        byte_val = buf[byte_index]
        chunk = (byte_val >> bit_index) & chunk_mask
        out |= (chunk << shift)
        remaining -= bits_here
        bit_pos += bits_here
        shift += bits_here
    if signed:
        sign_bit = 1 << (size - 1)
        if out & sign_bit:
            out = out - (1 << size)
    return out


def _phys_to_raw(v, factor, offset, size, signed):
    if factor == 0:
        raw = int(round(v - offset))
    else:
        raw = int(round((v - offset) / factor))
    if signed:
        min_raw = -(1 << (size - 1))
        max_raw = (1 << (size - 1)) - 1
    else:
        min_raw = 0
        max_raw = (1 << size) - 1
    if raw < min_raw:
        raw = min_raw
    if raw > max_raw:
        raw = max_raw
    return raw


def _raw_to_phys(raw, factor, offset):
    return raw * factor + offset


# --- Message metadata (embedded) ---
MESSAGES = [
% for m in messages:
    {
        "name": ${repr(m.name)},
        "id": ${m.message_id},
        "dlc": ${m.dlc},
        "signals": [
        % for s in m.signals:
            {
                "name": ${repr(s.name)},
                "start": ${s.start_bit},
                "size": ${s.size},
                "le": ${'True' if s.little_endian else 'False'},
                "signed": ${'True' if s.signed else 'False'},
                "factor": ${float(s.factor)},
                "offset": ${float(s.offset)},
            },
        % endfor
        ],
    },
% endfor
]


def encode_message_by_name(name, values):
    for m in MESSAGES:
        if m["name"] == name:
            return _encode_message(m, values)
    raise ValueError("unknown message: %s" % (name,))


def _encode_message(meta, values):
    data = bytearray([0] * meta["dlc"])
    for s in meta["signals"]:
        if not s["le"]:
            raise NotImplementedError("big-endian signals not supported in this generator")
        phys = float(values.get(s["name"], 0.0))
        raw = _phys_to_raw(phys, s["factor"], s["offset"], s["size"], s["signed"])
        _ins_bits_le(data, s["start"], s["size"], raw)
    return meta["id"], bytes(data), meta["dlc"]


def decode_message_by_id(can_id, data_bytes):
    for m in MESSAGES:
        if m["id"] == can_id:
            return _decode_message(m, data_bytes)
    raise ValueError("unknown message id: %d" % (can_id,))


def _decode_message(meta, data_bytes):
    res = {}
    for s in meta["signals"]:
        if not s["le"]:
            raise NotImplementedError("big-endian signals not supported in this generator")
        raw = _ext_bits_le(data_bytes, s["start"], s["size"], s["signed"])
        phys = _raw_to_phys(raw, s["factor"], s["offset"])
        res[s["name"]] = phys
    return {"message": meta["name"], "signals": res}


class PythonCanSender:
    def __init__(self, **bus_kwargs):
        self._bus = can.Bus(**bus_kwargs)

    def send(self, arbitration_id: int, data: bytes, is_extended_id: bool = False) -> None:
        msg = can.Message(
            arbitration_id=arbitration_id,
            is_extended_id=is_extended_id,
            data=data,
        )
        self._bus.send(msg)

    def shutdown(self) -> None:
        try:
            self._bus.shutdown()
        except Exception:
            pass


class PythonCanReceiver:
    def __init__(self, **bus_kwargs):
        self._bus = can.Bus(**bus_kwargs)

    def recv(self, timeout: Optional[float] = None):
        return self._bus.recv(timeout=timeout)

    def decode_frame(self, frame) -> Dict[str, Any]:
        return decode_message_by_id(frame.arbitration_id, bytes(frame.data))

    def shutdown(self) -> None:
        try:
            self._bus.shutdown()
        except Exception:
            pass


if __name__ == "__main__":
    # Basic smoke-test on desktop CPython (no CAN):
    if MESSAGES:
        mid, data, dlc = _encode_message(MESSAGES[0], {})
        out = _decode_message(MESSAGES[0], data)
        print("Encoded id=0x%X dlc=%d data=%s" % (mid, dlc, data))
        print("Decoded:", out)