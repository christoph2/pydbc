## -*- coding: utf-8 -*-
## Mako template: MicroPython CAN app generated by pydbc
<%
# messages: List[CGMessage]
# app_name: str
%>
"""
Auto-generated MicroPython CAN application: ${app_name}

Generated by pydbc using Mako templates. This code is standalone and embeds
all message/signal metadata (no runtime database needed).

Limitations:
- Only little-endian signals are handled in the helpers below.
- Multiplexing not implemented in this minimal generator.
"""
try:
    from machine import CAN  # ESP32, etc.
    PLATFORM = "machine"
except Exception:  # pragma: no cover
    try:
        from pyb import CAN  # Pyboard
        PLATFORM = "pyb"
    except Exception:
        CAN = None
        PLATFORM = "none"

# --- Bit helpers (little-endian/Intel) ---
def _ins_bits_le(buf, start_bit, size, value):
    if size <= 0:
        return
    mask = (1 << size) - 1
    value &= mask
    bit_pos = start_bit
    remaining = size
    while remaining > 0:
        byte_index = bit_pos // 8
        bit_index = bit_pos % 8
        bits_here = min(remaining, 8 - bit_index)
        chunk_mask = (1 << bits_here) - 1
        chunk = value & chunk_mask
        buf[byte_index] &= ~(chunk_mask << bit_index)
        buf[byte_index] |= (chunk << bit_index)
        value >>= bits_here
        remaining -= bits_here
        bit_pos += bits_here


def _ext_bits_le(buf, start_bit, size, signed):
    if size <= 0:
        return 0
    bit_pos = start_bit
    remaining = size
    out = 0
    shift = 0
    while remaining > 0:
        byte_index = bit_pos // 8
        bit_index = bit_pos % 8
        bits_here = min(remaining, 8 - bit_index)
        chunk_mask = (1 << bits_here) - 1
        byte_val = buf[byte_index]
        chunk = (byte_val >> bit_index) & chunk_mask
        out |= (chunk << shift)
        remaining -= bits_here
        bit_pos += bits_here
        shift += bits_here
    if signed:
        sign_bit = 1 << (size - 1)
        if out & sign_bit:
            out = out - (1 << size)
    return out


def _phys_to_raw(v, factor, offset, size, signed):
    if factor == 0:
        raw = int(round(v - offset))
    else:
        raw = int(round((v - offset) / factor))
    if signed:
        min_raw = -(1 << (size - 1))
        max_raw = (1 << (size - 1)) - 1
    else:
        min_raw = 0
        max_raw = (1 << size) - 1
    if raw < min_raw:
        raw = min_raw
    if raw > max_raw:
        raw = max_raw
    return raw


def _raw_to_phys(raw, factor, offset):
    return raw * factor + offset


# --- Message metadata (embedded) ---
MESSAGES = [
% for m in messages:
    {
        "name": ${repr(m.name)},
        "id": ${m.message_id},
        "dlc": ${m.dlc},
        "signals": [
        % for s in m.signals:
            {
                "name": ${repr(s.name)},
                "start": ${s.start_bit},
                "size": ${s.size},
                "le": ${'True' if s.little_endian else 'False'},
                "signed": ${'True' if s.signed else 'False'},
                "factor": ${float(s.factor)},
                "offset": ${float(s.offset)},
            },
        % endfor
        ],
    },
% endfor
]


def encode_message_by_name(name, values):
    for m in MESSAGES:
        if m["name"] == name:
            return _encode_message(m, values)
    raise ValueError("unknown message: %s" % (name,))


def _encode_message(meta, values):
    data = bytearray([0] * meta["dlc"])
    for s in meta["signals"]:
        if not s["le"]:
            raise NotImplementedError("big-endian signals not supported in this generator")
        phys = float(values.get(s["name"], 0.0))
        raw = _phys_to_raw(phys, s["factor"], s["offset"], s["size"], s["signed"])
        _ins_bits_le(data, s["start"], s["size"], raw)
    return meta["id"], bytes(data), meta["dlc"]


def decode_message_by_id(can_id, data_bytes):
    for m in MESSAGES:
        if m["id"] == can_id:
            return _decode_message(m, data_bytes)
    raise ValueError("unknown message id: %d" % (can_id,))


def _decode_message(meta, data_bytes):
    res = {}
    for s in meta["signals"]:
        if not s["le"]:
            raise NotImplementedError("big-endian signals not supported in this generator")
        raw = _ext_bits_le(data_bytes, s["start"], s["size"], s["signed"])
        phys = _raw_to_phys(raw, s["factor"], s["offset"])
        res[s["name"]] = phys
    return {"message": meta["name"], "signals": res}


def demo_send_once(channel=0, id_mode=CAN.STD):
    if CAN is None:
        print("No CAN class available on this platform.")
        return
    can = CAN(channel, mode=CAN.NORMAL, prescaler=100, sjw=1, bs1=6, bs2=8)
    # Send the first message with zeroed values as a demo
    if not MESSAGES:
        print("No messages embedded.")
        return
    mid, data, dlc = _encode_message(MESSAGES[0], {})
    try:
        can.send(data, mid, timeout=100)
        print("Sent 0x%X -> %s" % (mid, data))
    except Exception as e:
        print("Send failed:", e)


if __name__ == "__main__":
    # Basic smoke-test on desktop CPython (no CAN):
    if MESSAGES:
        mid, data, dlc = _encode_message(MESSAGES[0], {})
        out = _decode_message(MESSAGES[0], data)
        print("Encoded id=0x%X dlc=%d data=%s" % (mid, dlc, data))
        print("Decoded:", out)
