/*
 * Auto-generated Linux SocketCAN application: ${program_name}
 * Generated by pydbc using Mako templates. Standalone: embeds all metadata.
 *
 * Build (example):
 *   gcc -O2 -Wall -o ${program_name} ${program_name}.c
 * Run (example):
 *   sudo ./${program_name} vcan0
 *
 * Limitations:
 * - Only little-endian signals handled in helpers below.
 * - Multiplexing not implemented in this minimal generator.
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <linux/can.h>
#include <linux/can/raw.h>
#include <sys/ioctl.h>

typedef struct {
    const char *name;
    uint16_t start; // bit start
    uint8_t size;   // bit size
    bool le;        // little-endian
    bool sign;      // true if signed
    double factor;
    double offset;
} cg_signal_t;

typedef struct {
    const char *name;
    uint32_t id;
    uint8_t dlc;
    const cg_signal_t *signals;
    size_t num_signals;
} cg_message_t;

static inline void ins_bits_le(uint8_t *buf, uint16_t start, uint8_t size, int64_t value) {
    if (size == 0) return;
    uint64_t mask = (size >= 64) ? ~0ULL : ((1ULL << size) - 1ULL);
    uint64_t v = ((uint64_t)value) & mask;
    uint16_t bit_pos = start;
    uint8_t remaining = size;
    while (remaining > 0) {
        uint16_t byte_index = bit_pos / 8u;
        uint8_t bit_index = bit_pos % 8u;
        uint8_t bits_here = (uint8_t)((remaining < (8u - bit_index)) ? remaining : (8u - bit_index));
        uint8_t chunk_mask = (uint8_t)((1u << bits_here) - 1u);
        uint8_t chunk = (uint8_t)(v & chunk_mask);
        buf[byte_index] &= (uint8_t)~(chunk_mask << bit_index);
        buf[byte_index] |= (uint8_t)(chunk << bit_index);
        v >>= bits_here;
        remaining -= bits_here;
        bit_pos += bits_here;
    }
}

static inline int64_t ext_bits_le(const uint8_t *buf, uint16_t start, uint8_t size, bool sign) {
    if (size == 0) return 0;
    uint16_t bit_pos = start;
    uint8_t remaining = size;
    uint64_t out = 0;
    uint8_t shift = 0;
    while (remaining > 0) {
        uint16_t byte_index = bit_pos / 8u;
        uint8_t bit_index = bit_pos % 8u;
        uint8_t bits_here = (uint8_t)((remaining < (8u - bit_index)) ? remaining : (8u - bit_index));
        uint8_t chunk_mask = (uint8_t)((1u << bits_here) - 1u);
        uint8_t byte_val = buf[byte_index];
        uint8_t chunk = (uint8_t)((byte_val >> bit_index) & chunk_mask);
        out |= ((uint64_t)chunk) << shift;
        remaining -= bits_here;
        bit_pos += bits_here;
        shift += bits_here;
    }
    if (sign) {
        uint64_t sign_bit = 1ULL << (size - 1);
        if (out & sign_bit) {
            out = out - (1ULL << size);
        }
    }
    return (int64_t)out;
}

static inline int64_t phys_to_raw(double v, double factor, double offset, uint8_t size, bool sign) {
    double rawd = (factor == 0.0) ? (v - offset) : ((v - offset) / factor);
    int64_t raw = (int64_t)( (rawd >= 0.0) ? (rawd + 0.5) : (rawd - 0.5) );
    if (sign) {
        int64_t minv = -(1LL << (size - 1));
        int64_t maxv =  (1LL << (size - 1)) - 1LL;
        if (raw < minv) raw = minv;
        if (raw > maxv) raw = maxv;
    } else {
        int64_t minv = 0;
        int64_t maxv = (size == 63) ? INT64_MAX : ((1LL << size) - 1LL);
        if (raw < minv) raw = minv;
        if (raw > maxv) raw = maxv;
    }
    return raw;
}

/* Embedded database */
% for m in messages:
static const cg_signal_t sigs_${m.message_id}[] = {
%   for s in m.signals:
    { ${repr(s.name)}, ${s.start_bit}, ${s.size}, ${'true' if s.little_endian else 'false'}, ${'true' if s.signed else 'false'}, ${float(s.factor)}, ${float(s.offset)} },
%   endfor
};
% endfor

static const cg_message_t MESSAGES[] = {
% for m in messages:
    { ${repr(m.name)}, ${m.message_id}, ${m.dlc}, sigs_${m.message_id}, sizeof(sigs_${m.message_id})/sizeof(sigs_${m.message_id}[0]) },
% endfor
};
static const size_t NUM_MESSAGES = sizeof(MESSAGES)/sizeof(MESSAGES[0]);

static const cg_message_t* find_msg_by_name(const char *name) {
    for (size_t i = 0; i < NUM_MESSAGES; ++i) {
        if (MESSAGES[i].name && strcmp(MESSAGES[i].name, name) == 0) return &MESSAGES[i];
    }
    return NULL;
}

static const cg_message_t* find_msg_by_id(uint32_t id) {
    for (size_t i = 0; i < NUM_MESSAGES; ++i) {
        if (MESSAGES[i].id == id) return &MESSAGES[i];
    }
    return NULL;
}

/* Encode values[] (parallel arrays) into frame data */
static void encode_message(const cg_message_t *m, const double *values, uint8_t *out_data) {
    memset(out_data, 0, m->dlc);
    for (size_t i = 0; i < m->num_signals; ++i) {
        const cg_signal_t *s = &m->signals[i];
        if (!s->le) {
            fprintf(stderr, "Big-endian signal not supported: %s\n", s->name);
            continue;
        }
        int64_t raw = phys_to_raw(values[i], s->factor, s->offset, s->size, s->sign);
        ins_bits_le(out_data, s->start, s->size, raw);
    }
}

/* Decode frame data into values[] */
static void decode_message(const cg_message_t *m, const uint8_t *data, double *values_out) {
    for (size_t i = 0; i < m->num_signals; ++i) {
        const cg_signal_t *s = &m->signals[i];
        if (!s->le) {
            fprintf(stderr, "Big-endian signal not supported: %s\n", s->name);
            values_out[i] = 0.0;
            continue;
        }
        int64_t raw = ext_bits_le(data, s->start, s->size, s->sign);
        values_out[i] = raw * s->factor + s->offset;
    }
}

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <ifname>\n", argv[0]);
        return 1;
    }
    const char *ifname = argv[1];

    int s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (s < 0) {
        perror("socket");
        return 1;
    }

    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
    if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {
        perror("SIOCGIFINDEX");
        close(s);
        return 1;
    }

    struct sockaddr_can addr;
    memset(&addr, 0, sizeof(addr));
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(s);
        return 1;
    }

    if (NUM_MESSAGES == 0) {
        fprintf(stderr, "No embedded messages to demo.\n");
        close(s);
        return 0;
    }

    const cg_message_t *m = &MESSAGES[0];
    double *vals = calloc(m->num_signals, sizeof(double));
    if (!vals) { perror("calloc"); close(s); return 1; }

    uint8_t data[8];
    encode_message(m, vals, data);

    struct can_frame tx;
    memset(&tx, 0, sizeof(tx));
    tx.can_id = m->id;
    tx.can_dlc = m->dlc;
    memcpy(tx.data, data, m->dlc);

    if (write(s, &tx, sizeof(tx)) != sizeof(tx)) {
        perror("write");
    } else {
        printf("Sent 0x%X ->", m->id);
        for (int i = 0; i < m->dlc; ++i) printf(" %02X", tx.data[i]);
        printf("\n");
    }

    struct can_frame rx;
    ssize_t n = read(s, &rx, sizeof(rx));
    if (n == sizeof(rx)) {
        const cg_message_t *mr = find_msg_by_id(rx.can_id);
        if (mr) {
            double *decoded = calloc(mr->num_signals, sizeof(double));
            if (decoded) {
                decode_message(mr, rx.data, decoded);
                printf("Received 0x%X, decoded %zu signals\n", rx.can_id, mr->num_signals);
                free(decoded);
            }
        } else {
            printf("Received unknown id 0x%X\n", rx.can_id);
        }
    }

    free(vals);
    close(s);
    return 0;
}
